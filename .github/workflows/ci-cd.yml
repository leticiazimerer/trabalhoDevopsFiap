name: CI/CD - ESGMonitoring (auto-path)
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Show repo tree (debug)
        run: |
          echo "::group::TOP LEVEL"
          ls -la
          echo "::endgroup::"
          echo "::group::FIND .csproj / Dockerfile"
          git ls-files '**/*.csproj' || true
          git ls-files '**/Dockerfile' || true
          echo "::endgroup::"
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - name: Locate projects
        id: loc
        shell: bash
        run: |
          set -e
          API_CSPROJ="$(git ls-files '**/ESGMonitoring.API.csproj' | head -n1 || true)"
          TESTS_CSPROJ="$(git ls-files '**/ESGMonitoring.Tests.csproj' | head -n1 || true)"
          DOCKERFILE_PATH="$(git ls-files '**/Dockerfile' | head -n1 || true)"
          echo "API_CSPROJ=$API_CSPROJ"
          echo "TESTS_CSPROJ=$TESTS_CSPROJ"
          echo "DOCKERFILE_PATH=$DOCKERFILE_PATH"
          if [ -z "$API_CSPROJ" ]; then
            echo "❌ Não achei ESGMonitoring.API.csproj."
            exit 1
          fi
          if [ -z "$DOCKERFILE_PATH" ]; then
            echo "❌ Não achei Dockerfile."
            exit 1
          fi
          echo "api_csproj=$API_CSPROJ" >> $GITHUB_OUTPUT
          echo "tests_csproj=$TESTS_CSPROJ" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT
          DOCKER_CTX="$(dirname "$DOCKERFILE_PATH")"
          echo "docker_ctx=$DOCKER_CTX" >> $GITHUB_OUTPUT
      - name: Restore
        run: dotnet restore "${{ steps.loc.outputs.api_csproj }}"
      - name: Build
        run: dotnet build "${{ steps.loc.outputs.api_csproj }}" -c Release --no-restore
      - name: Test (if tests project exists)
        if: ${{ steps.loc.outputs.tests_csproj != '' }}
        run: dotnet test "${{ steps.loc.outputs.tests_csproj }}" -c Release --no-build --logger "trx;LogFileName=test_results.trx"
      - name: Archive Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: "**/test_results.trx"

  docker-build-push:
    needs: build-test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/esgmonitoring-api
    steps:
      - uses: actions/checkout@v4
      - name: Locate or create Dockerfile
        id: loc
        shell: bash
        run: |
          set -e
          DF="$(git ls-files '**/Dockerfile' | head -n1 || true)"
          if [ -z "$DF" ]; then
            echo "No Dockerfile found. Creating one at repo root..."
            cat > Dockerfile <<'DOCKER'
  FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
  WORKDIR /src
  COPY src/ESGMonitoring.API/ESGMonitoring.API.csproj src/ESGMonitoring.API/
  COPY src/ESGMonitoring.Tests/ESGMonitoring.Tests.csproj src/ESGMonitoring.Tests/
  RUN dotnet restore src/ESGMonitoring.API/ESGMonitoring.API.csproj
  COPY src/ESGMonitoring.API/ src/ESGMonitoring.API/
  COPY src/ESGMonitoring.Tests/ src/ESGMonitoring.Tests/
  RUN dotnet build src/ESGMonitoring.API/ESGMonitoring.API.csproj -c Release -o /app/build
  RUN dotnet test src/ESGMonitoring.Tests/ESGMonitoring.Tests.csproj -c Release --no-build --logger "trx;LogFileName=test_results.trx"
  FROM build AS publish
  RUN dotnet publish src/ESGMonitoring.API/ESGMonitoring.API.csproj -c Release -o /app/publish /p:UseAppHost=false
  FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
  WORKDIR /app
  EXPOSE 8080
  ENV ASPNETCORE_URLS=http://+:8080
  COPY --from=publish /app/publish .
  ENTRYPOINT ["dotnet", "ESGMonitoring.API.dll"]
  DOCKER
  DF="Dockerfile"
  CTX="."
  else
  CTX="$(dirname "$DF")"
  fi
  echo "dockerfile=$DF" >> $GITHUB_OUTPUT
  echo "docker_ctx=$CTX" >> $GITHUB_OUTPUT
- name: Log in to GHCR
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}
- name: Build image
  run: docker build -f "${{ steps.loc.outputs.dockerfile }}" -t $IMAGE_NAME:${{ github.sha }} "${{ steps.loc.outputs.docker_ctx }}"
- name: Push image
  run: docker push $IMAGE_NAME:${{ github.sha }}

deploy-staging:
  needs: docker-build-push
  runs-on: ubuntu-latest
  environment: staging
  steps:
    - name: Deploy to staging via SSH
      uses: appleboy/ssh-action@v1.2.0
      with:
        host: ${{ secrets.SSH_HOST_STAGING }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          set -e
          export IMAGE=ghcr.io/${{ github.repository_owner }}/esgmonitoring-api:${{ github.sha }}
          mkdir -p ~/esg-app && cd ~/esg-app
          cat > docker-compose.yml << 'YAML'
          services:
            api:
              image: $IMAGE
              ports:
                - "8080:8080"
              environment:
                - ASPNETCORE_ENVIRONMENT=Staging
          YAML
          docker compose pull || true
          docker compose up -d --remove-orphans

deploy-production:
  needs: deploy-staging
  if: github.ref == 'refs/heads/main' && github.event_name == 'workflow_dispatch'
  runs-on: ubuntu-latest
  environment: production
  steps:
    - name: Deploy to production via SSH
      uses: appleboy/ssh-action@v1.2.0
      with:
        host: ${{ secrets.SSH_HOST_PROD }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          set -e
          export IMAGE=ghcr.io/${{ github.repository_owner }}/esgmonitoring-api:${{ github.sha }}
          mkdir -p ~/esg-app && cd ~/esg-app
          cat > docker-compose.yml << 'YAML'
          services:
            api:
              image: $IMAGE
              ports:
                - "80:8080"
              environment:
                - ASPNETCORE_ENVIRONMENT=Production
          YAML
          docker compose pull || true
          docker compose up -d --remove-orphans